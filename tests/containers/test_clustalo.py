# Generated by CodiumAI
from pyEED.aligners.clustalo import ClustalOmega
from sqlalchemy import Sequence
import os
import docker
from Bio.Align import MultipleSeqAlignment
from Bio import AlignIO


# Dependencies:
# pip install pytest-mock
import pytest


class TestClustalOmega:
    # ClustalOmega aligns multiple sequences and returns the alignment result.
    def test_align_multiple_sequences(self, mocker):
        # Mock the necessary dependencies
        mocker.patch.object(ClustalOmega, "run_container")
        mocker.patch.object(ClustalOmega, "extract_output_data")

        # Create a mock alignment result
        alignment_result = MultipleSeqAlignment([])

        # Set up the mock return values
        ClustalOmega.run_container.return_value = None
        ClustalOmega.extract_output_data.return_value = alignment_result

        # Create a list of mock sequences
        sequences = [
            Sequence(source_id="seq1", sequence="ATCG"),
            Sequence(source_id="seq2", sequence="GCTA"),
        ]

        # Invoke the align method
        result = ClustalOmega.align(sequences)

        # Assert that the align method was called with the correct arguments
        ClustalOmega.run_container.assert_called_once_with(
            command=ClustalOmega.setup_command(), data=sequences
        )

        # Assert that the extract_output_data method was called
        ClustalOmega.extract_output_data.assert_called_once()

        # Assert that the result is the expected alignment result
        assert result == alignment_result

    # ClustalOmega sets up the input data for the container.
    def test_setup_input_data(self, mocker):
        # Mock the necessary dependencies
        mocker.patch.object(ClustalOmega, "_tempdir_path")

        # Create a list of mock sequences
        sequences = [
            Sequence(source_id="seq1", sequence="ATCG"),
            Sequence(source_id="seq2", sequence="GCTA"),
        ]

        # Invoke the create_file method
        ClustalOmega.create_file(sequences)

        # Assert that the input file was created with the correct content
        with open(os.path.join(ClustalOmega._tempdir_path, "input.fasta"), "r") as file:
            content = file.read()
            assert content == ">seq1\nATCG\n>seq2\nGCTA"

    # ClustalOmega sets up the command to run the container.
    def test_setup_command(self):
        # Invoke the setup_command method
        command = ClustalOmega().setup_command()

        # Assert that the command is the expected value
        assert (
            command == "clustalo -i /data/input.fasta -o /data/output.clu --outfmt=clu"
        )

    # ClustalOmega raises an error if the container fails to run.
    def test_run_container_error(self, mocker):
        # Mock the necessary dependencies
        mocker.patch.object(ClustalOmega, "get_image")
        mocker.patch.object(ClustalOmega, "create_file")
        mocker.patch.object(
            ClustalOmega._client.containers,
            "run",
            side_effect=Exception("Container error"),
        )

        # Create a list of mock sequences
        sequences = [
            Sequence(source_id="seq1", sequence="ATCG"),
            Sequence(source_id="seq2", sequence="GCTA"),
        ]

        # Invoke the run_container method
        with pytest.raises(Exception):
            ClustalOmega.run_container(
                command=ClustalOmega.setup_command(), data=sequences
            )

        # Assert that the get_image method was called
        ClustalOmega.get_image.assert_called_once()

        # Assert that the create_file method was called
        ClustalOmega.create_file.assert_called_once_with(data=sequences)

        # Assert that the run method was called with the correct arguments
        ClustalOmega._client.containers.run.assert_called_once_with(
            image=ClustalOmega.get_image.return_value,
            command=ClustalOmega.setup_command(),
            name=ClustalOmega._container_info.name,
            auto_remove=True,
            volumes={ClustalOmega._tempdir_path: {"bind": "/data/", "mode": "rw"}},
        )

    # ClustalOmega raises an error if the image is not found.
    def test_get_image_image_not_found(self, mocker):
        # Mock the necessary dependencies
        mocker.patch.object(
            ClustalOmega._client.images,
            "get",
            side_effect=docker.errors.ImageNotFound("Image not found"),
        )
        mocker.patch.object(ClustalOmega._client.images, "pull")

        # Invoke the get_image method
        image = ClustalOmega.get_image()

        # Assert that the image is the pulled image
        assert image == ClustalOmega._client.images.pull.return_value

        # Assert that the get method was called with the correct argument
        ClustalOmega._client.images.get.assert_called_once_with(
            ClustalOmega._container_info.value
        )

        # Assert that the pull method was called
        ClustalOmega._client.images.pull.assert_called_once_with(
            ClustalOmega._container_info.value
        )

    # ClustalOmega raises an error if the output data cannot be extracted.
    def test_extract_output_data_error(self, mocker):
        # Mock the necessary dependencies
        mocker.patch.object(ClustalOmega, "_delete_temp_dir")
        mocker.patch.object(AlignIO, "read", side_effect=Exception("Extraction error"))

        # Invoke the extract_output_data method
        with pytest.raises(Exception):
            ClustalOmega.extract_output_data()

        # Assert that the _delete_temp_dir method was called
        ClustalOmega._delete_temp_dir.assert_called_once()

        # Assert that the read method was called with the correct arguments
        AlignIO.read.assert_called_once_with(
            os.path.join(ClustalOmega._tempdir_path, "output.clu"), "clustal"
        )
